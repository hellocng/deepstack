---
description: Core project standards and conventions for the poker room management app
globs: ['**/*']
alwaysApply: true
---

# DeepStack - Project Standards

## Terminology Standardization

**CRITICAL**: The following terms are synonymous and must be used consistently:

- **Room** (preferred) - The primary term for a poker room/establishment
- **Tenant** - Database/technical term (legacy, being phased out)
- **Operator** - Business term referring to room staff/management

**Usage Guidelines**:

- Use "room" in user-facing content, URLs, and new code
- "tenant" may still appear in database schemas and legacy code
- "operator" refers to room staff/management, not the room itself
- Always be consistent within the same context
- When in doubt, use "room"

## Tech Stack & Architecture

- **Framework**: Next.js 14+ with App Router
- **Database**: Supabase (PostgreSQL)
- **Authentication**: Supabase OAuth
- **UI**: shadcn/ui with Tailwind CSS
- **Language**: TypeScript (strict mode)
- **Forms**: React Hook Form with Zod validation

## Code Style & Conventions

### TypeScript

- Use strict TypeScript configuration
- Define interfaces for all data structures
- Use proper type annotations for function parameters and return types
- Prefer `interface` over `type` for object shapes
- Use `const assertions` for immutable data

### File Naming

- Use kebab-case for file names: `user-profile.tsx`
- Use PascalCase for component files: `UserProfile.tsx`
- Use camelCase for utility files: `formatCurrency.ts`
- Use UPPER_CASE for constants: `API_ENDPOINTS.ts`

### Component Structure

```typescript
// 1. Imports (external libraries first, then internal)
import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { User } from '@/types/user'

// 2. Interface definitions
interface UserProfileProps {
  user: User
  onUpdate: (user: User) => void
}

// 3. Component definition
export function UserProfile({ user, onUpdate }: UserProfileProps) {
  // 4. State and hooks
  const [isEditing, setIsEditing] = useState(false)

  // 5. Event handlers
  const handleSave = () => {
    // Implementation
  }

  // 6. Render
  return (
    <div>
      {/* JSX */}
    </div>
  )
}
```

## Database Conventions

### Naming

- Use snake_case for table and column names
- Use plural names for tables: `users`, `games`, `tournaments`
- Use descriptive foreign key names: `user_id`, `game_id`

### Supabase Patterns

- Always use Row Level Security (RLS) policies
- Use Supabase client for all database operations
- Implement proper error handling for database calls
- Use TypeScript types generated from database schema

## Authentication & Authorization

### User Roles

- `player`: Can view games, join waitlists, see friends
- `operator`: Can manage games, tables, tournaments
- `admin`: Full system access

### Route Protection

- Use middleware for route protection
- Implement tenant-based access control
- Validate user permissions at component level

## Multitenant Architecture

### URL Structure

```
/[tenant]          # Player pages
/[tenant]/admin    # Operator pages
```

### Tenant Handling

- Extract tenant from URL params
- Validate tenant exists and user has access
- Use tenant context throughout the app
- Implement tenant-specific data isolation

## Error Handling

### API Errors

- Use try-catch blocks for all async operations
- Provide meaningful error messages
- Log errors appropriately
- Show user-friendly error states

### Form Validation

- **Use React Hook Form for all forms** - Required for all form implementations
- **Use Zod for schema validation** - Required for form validation schemas
- **Use Field components from shadcn/ui** - Required for all form field implementations
- **Use Controller from react-hook-form** - Required for integrating form fields with React Hook Form
- Implement client-side and server-side validation
- Show validation errors inline using `FieldError` component
- Prevent form submission on validation errors
- Use `@hookform/resolvers/zod` for React Hook Form + Zod integration
- Follow the pattern: define Zod schema, use with `useForm` hook, use `Controller` with `Field` components

### Form Implementation Pattern

```typescript
import { Controller, useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import {
  Field,
  FieldError,
  FieldGroup,
  FieldLabel,
} from '@/components/ui/field'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'

// 1. Define Zod schema
const formSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email address'),
  phone: z.string().min(10, 'Phone number must be at least 10 digits')
})

type FormData = z.infer<typeof formSchema>

// 2. Use React Hook Form with Zod resolver
export function MyForm(): JSX.Element {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      email: '',
      phone: ''
    }
  })

  const onSubmit = (data: FormData): void => {
    // Handle form submission
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FieldGroup>
        <Controller
          name="name"
          control={form.control}
          render={({ field, fieldState }): JSX.Element => (
            <Field data-invalid={fieldState.invalid}>
              <FieldLabel htmlFor="name">Name</FieldLabel>
              <Input
                id="name"
                aria-invalid={fieldState.invalid}
                {...field}
              />
              {fieldState.invalid && (
                <FieldError errors={[fieldState.error]} />
              )}
            </Field>
          )}
        />
        <Controller
          name="email"
          control={form.control}
          render={({ field, fieldState }): JSX.Element => (
            <Field data-invalid={fieldState.invalid}>
              <FieldLabel htmlFor="email">Email</FieldLabel>
              <Input
                id="email"
                type="email"
                aria-invalid={fieldState.invalid}
                {...field}
              />
              {fieldState.invalid && (
                <FieldError errors={[fieldState.error]} />
              )}
            </Field>
          )}
        />
        <Controller
          name="phone"
          control={form.control}
          render={({ field, fieldState }): JSX.Element => (
            <Field data-invalid={fieldState.invalid}>
              <FieldLabel htmlFor="phone">Phone</FieldLabel>
              <Input
                id="phone"
                type="tel"
                aria-invalid={fieldState.invalid}
                {...field}
              />
              {fieldState.invalid && (
                <FieldError errors={[fieldState.error]} />
              )}
            </Field>
          )}
        />
      </FieldGroup>
      <Button type="submit">Submit</Button>
    </form>
  )
}
```

### Form Best Practices

- Always define Zod schemas for form validation
- Use TypeScript types inferred from Zod schemas
- **Always use Field components** - Never use the deprecated Form components
- **Always use Controller** - Never use form.register() or form.watch() directly
- Use `FieldGroup` to wrap multiple fields for consistent spacing
- Always include `data-invalid={fieldState.invalid}` on `Field` component
- Always include `aria-invalid={fieldState.invalid}` on form inputs for accessibility
- Conditionally render `FieldError` only when `fieldState.invalid` is true
- Provide meaningful validation error messages in Zod schemas
- Handle form submission states (loading, success, error)
- Use `form.reset()` to clear forms after successful submission
- Use `orientation="horizontal"` for switch/checkbox fields when appropriate
- For number inputs, handle value conversion with `onChange` handler: `onChange={(e) => field.onChange(Number(e.target.value))}`

## Performance

### Optimization

- Use React.memo for expensive components
- Implement proper loading states
- Use Supabase real-time efficiently
- Optimize images and assets
- Implement proper caching strategies

### Code Splitting

- Use dynamic imports for large components
- Implement route-based code splitting
- Lazy load non-critical features

## Testing

### Unit Tests

- Write tests for utility functions
- Test component behavior with user interactions
- Mock external dependencies
- Aim for 80%+ code coverage

### Integration Tests

- Test API endpoints
- Test authentication flows
- Test multitenant functionality
- Test real-time features

## Security

### Data Protection

- Never expose sensitive data in client-side code
- Use environment variables for secrets
- Implement proper input sanitization
- Use HTTPS in production

### Authentication

- Validate JWT tokens properly
- Implement proper session management
- Use secure cookie settings
- Implement rate limiting

## Documentation

### Code Comments

- Document complex business logic
- Explain non-obvious implementations
- Use JSDoc for function documentation
- Keep comments up to date

### README Updates

- Update README when adding new features
- Document API changes
- Include setup instructions for new dependencies
- Keep deployment instructions current

## Build and Development

- **NEVER run `npm run build` or `npm run lint` automatically**
- Only build and lint when explicitly requested by the user
- Do not run build commands as part of routine code changes
- Let the user control when to test builds and linting

### ESLint Migration

- **Migrate from `next lint` to ESLint CLI** - `next lint` is deprecated in Next.js 15+ and will be removed in Next.js 16
- Use migration command: `npx @next/codemod@canary next-lint-to-eslint-cli .`
- After migration, use `npx eslint .` instead of `npm run lint`
- Follow the ESLint configuration standards in `.cursor/rules/eslint-config.mdc`

## UI Components

- **Use `npx shadcn-ui@latest add [component-name]` to add new shadcn/ui components**
- Prefer using shadcn/ui components over custom implementations when available
- Only create custom components when shadcn/ui doesn't provide the needed functionality
- When adding components, use the latest version: `npx shadcn-ui@latest add [component-name]`
- Customize shadcn components using Tailwind CSS classes as needed
