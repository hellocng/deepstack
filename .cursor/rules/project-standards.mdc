---
description: Core project standards and conventions for the poker room management app
globs: ['**/*']
alwaysApply: true
---

# DeepStack - Project Standards

## Terminology Standardization

**CRITICAL**: The following terms are synonymous and must be used consistently:

- **Room** (preferred) - The primary term for a poker room/establishment
- **Tenant** - Database/technical term (legacy, being phased out)
- **Operator** - Business term referring to room staff/management

**Usage Guidelines**:

- Use "room" in user-facing content, URLs, and new code
- "tenant" may still appear in database schemas and legacy code
- "operator" refers to room staff/management, not the room itself
- Always be consistent within the same context
- When in doubt, use "room"

## Tech Stack & Architecture

- **Framework**: Next.js 14+ with App Router
- **Database**: Supabase (PostgreSQL)
- **Authentication**: Supabase OAuth
- **UI**: shadcn/ui with Tailwind CSS
- **Language**: TypeScript (strict mode)

## Code Style & Conventions

### TypeScript

- Use strict TypeScript configuration
- Define interfaces for all data structures
- Use proper type annotations for function parameters and return types
- Prefer `interface` over `type` for object shapes
- Use `const assertions` for immutable data

### File Naming

- Use kebab-case for file names: `user-profile.tsx`
- Use PascalCase for component files: `UserProfile.tsx`
- Use camelCase for utility files: `formatCurrency.ts`
- Use UPPER_CASE for constants: `API_ENDPOINTS.ts`

### Component Structure

```typescript
// 1. Imports (external libraries first, then internal)
import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { User } from '@/types/user'

// 2. Interface definitions
interface UserProfileProps {
  user: User
  onUpdate: (user: User) => void
}

// 3. Component definition
export function UserProfile({ user, onUpdate }: UserProfileProps) {
  // 4. State and hooks
  const [isEditing, setIsEditing] = useState(false)

  // 5. Event handlers
  const handleSave = () => {
    // Implementation
  }

  // 6. Render
  return (
    <div>
      {/* JSX */}
    </div>
  )
}
```

## Database Conventions

### Naming

- Use snake_case for table and column names
- Use plural names for tables: `users`, `games`, `tournaments`
- Use descriptive foreign key names: `user_id`, `game_id`

### Supabase Patterns

- Always use Row Level Security (RLS) policies
- Use Supabase client for all database operations
- Implement proper error handling for database calls
- Use TypeScript types generated from database schema

## Authentication & Authorization

### User Roles

- `player`: Can view games, join waitlists, see friends
- `operator`: Can manage games, tables, tournaments
- `admin`: Full system access

### Route Protection

- Use middleware for route protection
- Implement tenant-based access control
- Validate user permissions at component level

## Multitenant Architecture

### URL Structure

```
/[tenant]          # Player pages
/[tenant]/admin    # Operator pages
```

### Tenant Handling

- Extract tenant from URL params
- Validate tenant exists and user has access
- Use tenant context throughout the app
- Implement tenant-specific data isolation

## Error Handling

### API Errors

- Use try-catch blocks for all async operations
- Provide meaningful error messages
- Log errors appropriately
- Show user-friendly error states

### Form Validation

- Use Zod for schema validation
- Implement client-side and server-side validation
- Show validation errors inline
- Prevent form submission on validation errors

## Performance

### Optimization

- Use React.memo for expensive components
- Implement proper loading states
- Use Supabase real-time efficiently
- Optimize images and assets
- Implement proper caching strategies

### Code Splitting

- Use dynamic imports for large components
- Implement route-based code splitting
- Lazy load non-critical features

## Testing

### Unit Tests

- Write tests for utility functions
- Test component behavior with user interactions
- Mock external dependencies
- Aim for 80%+ code coverage

### Integration Tests

- Test API endpoints
- Test authentication flows
- Test multitenant functionality
- Test real-time features

## Security

### Data Protection

- Never expose sensitive data in client-side code
- Use environment variables for secrets
- Implement proper input sanitization
- Use HTTPS in production

### Authentication

- Validate JWT tokens properly
- Implement proper session management
- Use secure cookie settings
- Implement rate limiting

## Documentation

### Code Comments

- Document complex business logic
- Explain non-obvious implementations
- Use JSDoc for function documentation
- Keep comments up to date

### README Updates

- Update README when adding new features
- Document API changes
- Include setup instructions for new dependencies
- Keep deployment instructions current

## Build and Development

- **NEVER run `npm run build` or `npm run lint` automatically**
- Only build and lint when explicitly requested by the user
- Do not run build commands as part of routine code changes
- Let the user control when to test builds and linting

### ESLint Migration

- **Migrate from `next lint` to ESLint CLI** - `next lint` is deprecated in Next.js 15+ and will be removed in Next.js 16
- Use migration command: `npx @next/codemod@canary next-lint-to-eslint-cli .`
- After migration, use `npx eslint .` instead of `npm run lint`
- Follow the ESLint configuration standards in `.cursor/rules/eslint-config.mdc`

## UI Components

- **Use `npx shadcn-ui@latest add [component-name]` to add new shadcn/ui components**
- Prefer using shadcn/ui components over custom implementations when available
- Only create custom components when shadcn/ui doesn't provide the needed functionality
- When adding components, use the latest version: `npx shadcn-ui@latest add [component-name]`
- Customize shadcn components using Tailwind CSS classes as needed
