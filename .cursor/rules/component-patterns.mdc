---
description: Component patterns and UI standards for consistent development
globs: ["**/components/**/*", "**/app/**/*"]
alwaysApply: false
---

# DeepStack - Component Patterns & UI Standards

## shadcn/ui Integration

### Component Installation
- **NEVER manually create UI components** - always use `npx shadcn@latest add [component-name]`
- Use the official shadcn/ui CLI to install components
- Available components: button, card, input, label, dialog, dropdown-menu, etc.
- Example: `npx shadcn@latest add button card input`

### Component Usage
- Always use shadcn/ui components when available
- Extend shadcn components rather than creating from scratch
- Follow shadcn naming conventions
- Use proper component composition

### Custom Components
```typescript
// Extend shadcn components
import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'

interface CustomButtonProps extends React.ComponentProps<typeof Button> {
  variant?: 'primary' | 'secondary' | 'danger'
}

export function CustomButton({ 
  className, 
  variant = 'primary', 
  ...props 
}: CustomButtonProps) {
  return (
    <Button
      className={cn(
        variant === 'primary' && 'bg-blue-600 hover:bg-blue-700',
        variant === 'secondary' && 'bg-gray-600 hover:bg-gray-700',
        variant === 'danger' && 'bg-red-600 hover:bg-red-700',
        className
      )}
      {...props}
    />
  )
}
```

## Form Patterns

### Form Structure with Field Components

**CRITICAL**: shadcn/ui now uses `Field` components instead of `Form` components. Always use the `Field` component pattern with React Hook Form's `Controller`.

```typescript
import { Controller, useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import {
  Field,
  FieldError,
  FieldGroup,
  FieldLabel,
} from '@/components/ui/field'

const formSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email address'),
})

type FormData = z.infer<typeof formSchema>

export function UserForm({ onSubmit }: { onSubmit: (data: FormData) => void }): JSX.Element {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      email: '',
    },
  })

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
      <FieldGroup>
        <Controller
          name="name"
          control={form.control}
          render={({ field, fieldState }): JSX.Element => (
            <Field data-invalid={fieldState.invalid}>
              <FieldLabel htmlFor="name">Name</FieldLabel>
              <Input
                id="name"
                aria-invalid={fieldState.invalid}
                {...field}
              />
              {fieldState.invalid && (
                <FieldError errors={[fieldState.error]} />
              )}
            </Field>
          )}
        />
        <Controller
          name="email"
          control={form.control}
          render={({ field, fieldState }): JSX.Element => (
            <Field data-invalid={fieldState.invalid}>
              <FieldLabel htmlFor="email">Email</FieldLabel>
              <Input
                id="email"
                type="email"
                aria-invalid={fieldState.invalid}
                {...field}
              />
              {fieldState.invalid && (
                <FieldError errors={[fieldState.error]} />
              )}
            </Field>
          )}
        />
      </FieldGroup>
      <Button type="submit">Submit</Button>
    </form>
  )
}
```

### Field Component Pattern

**Required Pattern**:
1. Use `Controller` from `react-hook-form` for all form fields
2. Wrap fields in `FieldGroup` for proper layout
3. Use `Field` component with `data-invalid={fieldState.invalid}` for validation states
4. Use `FieldLabel` with proper `htmlFor` attributes
5. Add `aria-invalid={fieldState.invalid}` to inputs for accessibility
6. Conditionally render `FieldError` when `fieldState.invalid` is true

### Select Fields

```typescript
<Controller
  name="gameType"
  control={form.control}
  render={({ field, fieldState }): JSX.Element => (
    <Field data-invalid={fieldState.invalid}>
      <FieldLabel htmlFor="gameType">Game Type</FieldLabel>
      <Select
        value={field.value}
        onValueChange={field.onChange}
      >
        <SelectTrigger aria-invalid={fieldState.invalid}>
          <SelectValue placeholder="Select a game type" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="texas_holdem">Texas Hold'em</SelectItem>
          <SelectItem value="omaha">Omaha</SelectItem>
        </SelectContent>
      </Select>
      {fieldState.invalid && (
        <FieldError errors={[fieldState.error]} />
      )}
    </Field>
  )}
/>
```

### Checkbox and Switch Fields

```typescript
// Horizontal orientation for switches/checkboxes
<Controller
  name="isActive"
  control={form.control}
  render={({ field, fieldState }): JSX.Element => (
    <Field
      orientation="horizontal"
      data-invalid={fieldState.invalid}
      className="flex items-center space-x-2"
    >
      <Switch
        id="isActive"
        checked={field.value}
        onCheckedChange={field.onChange}
        aria-invalid={fieldState.invalid}
      />
      <FieldLabel htmlFor="isActive">Active</FieldLabel>
      {fieldState.invalid && (
        <FieldError errors={[fieldState.error]} />
      )}
    </Field>
  )}
/>
```

### Number Input Fields

```typescript
<Controller
  name="seatCount"
  control={form.control}
  render={({ field, fieldState }): JSX.Element => (
    <Field data-invalid={fieldState.invalid}>
      <FieldLabel htmlFor="seatCount">Seat Count</FieldLabel>
      <Input
        id="seatCount"
        type="number"
        min="2"
        max="10"
        aria-invalid={fieldState.invalid}
        {...field}
        onChange={(e): void => {
          field.onChange(Number(e.target.value))
        }}
        value={field.value}
      />
      {fieldState.invalid && (
        <FieldError errors={[fieldState.error]} />
      )}
    </Field>
  )}
/>
```

### Form Best Practices

- **NEVER use the old `Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormMessage` components**
- Always use `Controller` from `react-hook-form` for form field integration
- Use `FieldGroup` to wrap multiple fields for consistent spacing
- Always include `data-invalid` attribute on `Field` component for validation styling
- Always include `aria-invalid` attribute on form inputs for accessibility
- Conditionally render `FieldError` only when field is invalid
- Use `orientation="horizontal"` for switch/checkbox fields when label is beside the control
- For number inputs, handle value conversion manually with `onChange` handler

## Loading States

### Loading Components
```typescript
import { Skeleton } from '@/components/ui/skeleton'

export function GameCardSkeleton() {
  return (
    <div className="border rounded-lg p-4 space-y-3">
      <Skeleton className="h-4 w-3/4" />
      <Skeleton className="h-4 w-1/2" />
      <Skeleton className="h-8 w-full" />
    </div>
  )
}

export function LoadingSpinner({ size = 'default' }: { size?: 'sm' | 'default' | 'lg' }) {
  const sizeClasses = {
    sm: 'h-4 w-4',
    default: 'h-6 w-6',
    lg: 'h-8 w-8',
  }
  
  return (
    <div className={`animate-spin rounded-full border-2 border-gray-300 border-t-blue-600 ${sizeClasses[size]}`} />
  )
}
```

## Error States

### Error Components
```typescript
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'
import { AlertCircle } from 'lucide-react'

export function ErrorAlert({ 
  title, 
  message, 
  onRetry 
}: { 
  title?: string
  message: string
  onRetry?: () => void 
}) {
  return (
    <Alert variant="destructive">
      <AlertCircle className="h-4 w-4" />
      {title && <AlertTitle>{title}</AlertTitle>}
      <AlertDescription>
        {message}
        {onRetry && (
          <Button variant="outline" size="sm" onClick={onRetry} className="ml-2">
            Retry
          </Button>
        )}
      </AlertDescription>
    </Alert>
  )
}
```

## Data Display

### Table Components
```typescript
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'

interface DataTableProps<T> {
  data: T[]
  columns: {
    key: keyof T
    label: string
    render?: (value: T[keyof T], row: T) => React.ReactNode
  }[]
}

export function DataTable<T>({ data, columns }: DataTableProps<T>) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          {columns.map((column) => (
            <TableHead key={String(column.key)}>{column.label}</TableHead>
          ))}
        </TableRow>
      </TableHeader>
      <TableBody>
        {data.map((row, index) => (
          <TableRow key={index}>
            {columns.map((column) => (
              <TableCell key={String(column.key)}>
                {column.render 
                  ? column.render(row[column.key], row)
                  : String(row[column.key])
                }
              </TableCell>
            ))}
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}
```

## Real-time Components

### Supabase Real-time
```typescript
import { useEffect, useState } from 'react'
import { supabase } from '@/lib/supabase/client'

export function useRealtimeSubscription<T>(
  table: string,
  filter?: string
) {
  const [data, setData] = useState<T[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Initial fetch
    const fetchData = async () => {
      const { data, error } = await supabase
        .from(table)
        .select('*')
        .apply(filter ? { filter } : {})
      
      if (error) {
        console.error('Error fetching data:', error)
      } else {
        setData(data || [])
      }
      setLoading(false)
    }

    fetchData()

    // Set up real-time subscription
    const subscription = supabase
      .channel(`${table}_changes`)
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table 
        }, 
        (payload) => {
          // Handle real-time updates
          setData(prev => {
            // Update logic based on event type
            switch (payload.eventType) {
              case 'INSERT':
                return [...prev, payload.new as T]
              case 'UPDATE':
                return prev.map(item => 
                  (item as any).id === payload.new.id ? payload.new as T : item
                )
              case 'DELETE':
                return prev.filter(item => (item as any).id !== payload.old.id)
              default:
                return prev
            }
          })
        }
      )
      .subscribe()

    return () => {
      subscription.unsubscribe()
    }
  }, [table, filter])

  return { data, loading }
}
```

## Responsive Design

### Mobile-First Approach
- Use Tailwind's mobile-first breakpoints
- Design for mobile, then enhance for larger screens
- Use responsive utilities: `sm:`, `md:`, `lg:`, `xl:`

### Layout Patterns
```typescript
// Responsive grid
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {/* Grid items */}
</div>

// Responsive text
<h1 className="text-2xl md:text-3xl lg:text-4xl font-bold">
  Responsive Heading
</h1>

// Responsive spacing
<div className="p-4 md:p-6 lg:p-8">
  {/* Content */}
</div>
```

## Accessibility

### ARIA Labels
- Use proper ARIA labels for interactive elements
- Implement keyboard navigation
- Ensure proper color contrast
- Use semantic HTML elements

### Focus Management
```typescript
import { useEffect, useRef } from 'react'

export function Modal({ isOpen, onClose, children }: ModalProps) {
  const dialogRef = useRef<HTMLDialogElement>(null)

  useEffect(() => {
    if (isOpen) {
      dialogRef.current?.showModal()
      // Focus management
      const firstFocusable = dialogRef.current?.querySelector(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      ) as HTMLElement
      firstFocusable?.focus()
    } else {
      dialogRef.current?.close()
    }
  }, [isOpen])

  return (
    <dialog ref={dialogRef} onClose={onClose}>
      {children}
    </dialog>
  )
}
```